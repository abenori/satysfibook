% -*- coding: utf-8 -*-
@import: settings

let programming = '<
  +p{
    As I have already mentioned, \SATySFi; is a markup language for a typesetting with futures of functional languages.
    
    
    More precisely, it is a DSL (domain-specific language) which is equipped with various language functions for typesetting over the functional languages with call by value.
    Basic part of \SATySFi; as a programming language uses a syntax which is very similar to that of Ocaml.
    To understand the basic parts, one can use books on Ocaml such as \cite[`Igarashi-OCaml`]; and \cite[`Asai-OCaml`];.
    Or, it is also possible to be substituted by books on basic theries of computational languages and type systems such as \cite[`Igarashi-Program`]; and \cite[`TaPL`];.
    However, it is possible to learn programmings with \SATySFi; by getting intuition with \SATySFi;, without making a detour from other languages such as Ocaml.
    I think not all of readers do not want to basics of functional languages.
    So I briefly explain \SATySFi; as a programming language.
    There are also some differences between Ocaml and \SATySFi; comming from senses of purpose and aesthetics.
    For this (also for readers who can fluently do programming with Ocaml), I will add explanations in \ref-subsection(`diff-from-ocaml`);.
  }
  +subsection{Expressions and values}<
    +p{
      Because \SATySFi; does not have 対話環境, we will check the result of a program by outputting to PDF.
      First please take a look at the following code.

      \d-code(```
        @require: stdjareport

        let-inline \show-int n = embed-string (arabic n)
        let-inline \show-float x = embed-string (show-float x)
        let-inline \show-string s = embed-string s
        in

        document (|
          title = {Programming in \SATySFi;};
          author = {Santaro Kei};
        |) '<
          +p{ Answer: \show-int(40 + 2); }
        >
      ```);%

      \codem{let-inline}から始まる，
      未知でありながら前節で見たインラインコマンドを定義する方法によく似た構文が3つ連なっているが，
      Indeed, these are the definition of inline commands \codem{\\show-int}, \codem{\\show-float} and \codem{\\show-string}, respectively.
      You will understand how to read this definitions later.
      %% 「オマジナイ」ってなんて言うの？
      At this point, please think these as a オマジナイ which defines commands “to output a \meta-or{|integer|float|string|} (by decimal  system for numbers) to printed pages”.
      Please pay attention to the part where \codem{\\show-int} is used, namely 

      \d-code(```
        ​  +p{ Answer: \show-int(40 + 2); }
      ```);%

      
      There is a strange expression \codem{40 + 2} surrounded by parentheses.
      Anyway, let us process this document by \SATySFi;
      Then the paragraph corresponding to here is output as

      \d-block(open Sample in '<
        +p{ Answer: \show-int(40 + 2); }
      >);%

      Yes, the sum of ${40} and ${2} is calculated.
      To put it plainly, this kind of “calculation process” is a basic of works of the programming and describing a “calculation process” as a program is called programming.
      Expressions as \codem{40 + 2} is called \dfn{expression}, or sometimes \dfn{term} and program is constructed by arranging expressions with a suitable syntax\footnote{
        The readers who are familiar with languages based on a “procedural” viewpoint such as C programming language or Python may think “we make a statement from expressions and make a program from statements”.
        There is no notion of statements in \SATySFi;
        In fact, a special case of expressions corresponds to statements of “procedural” languages.
        This is a property common to many,  so-called functional languages such as Ocaml.
      }．
    }
    +p{
      As \codem{40 + 2} became to \codem{42} 
      \codem{40 + 2}の “計算が進んで” \codem{42}になったように，
      , in general, expressions “change” to  “expressions not calculated any further”.
      This process of “change” is called \dfn{evaluation} or \dfn{reduction} and “expressions not calculated any further” are called \dfn{syntactic value} or simply \dfn{value}.
      Action of program is to evaluate expressions and calculate values.
    }
    +p{
      Let us do a more complicated calculation.

      \d-code-and-block(```
        +p{ Answer: \show-int(1 + 2 * 3 - 4); }
      ```)(open Sample in '<
        +p{ Answer: \show-int(1 + 2 * 3 - 4); }
      >);%
      
      \codem{\*} is a binary operator for multiplications.
      When we write “${1 + 2 \times 3 - 4}”usually, it is regarded as ${\paren{1 + \paren{2 \times 3}} - 4}.
      Similarly, there is a priority between binary operators in the \SATySFi; language.
      Similar to usual formulas, you can clarify the priorities by enclosing them in parentheses.

      \d-code-and-block(```
        +p{ Answer: \show-int((1 + 2) * 3 - 4); }
      ```)(open Sample in '<
        +p{ Answer: \show-int((1 + 2) * 3 - 4); }
      >);%

      Integers in \SATySFi; is 63bit signed integer type with 64bit system and 31bit signed integer type with 32bit system\footnote{
        This behaviors is due to the specification of \code(`int`); in Ocaml which is used for the implementation of \SATySFi;
      }.
    }
  >
  +subsection?:(`variables`){Variables and binding}<
    +p{
      Simply calculating integers is not so much different from just using calculators.
      So let us do what is “more like programming”.
      Namely we use \dfn{variables}.
      Variables are identified by \dfn{variable names} and it is a mechanism which can \dfn{bind} certain values.
      The variable names should satisfy the following.

      \listing{
        * The first character is a lowercase latin character (\codem{a}–\codem{z})

        * The others are latin characters (\codem{a}–\codem{z}, \codem{A}–\codem{Z}), 
          numbers (\codem{0}–\codem{9}), or
          the hyphen (\codem{-}).
      }%
      
      However in the strings which satisfy the above, there are 39 exceptions.
      They are called \dfn{reserved words} and are used for special purposes such as showing(??) syntax.
      Therefore it is not allowed to use such words for variable names\footnote{
        \codem{controls} and \codem{cycle} do not have special meanings today.
        It was used in the TikZ-like syntax for graphics and they are still reserved words.
      }：

      \tokens{
        |and|as
        |before|block-cmd
        |command|constraint|controls|cycle
        |do|direct
        |else|end
        |false|fun
        |if|in|inline-cmd
        |let|let-block|let-inline|let-math|let-mutable|let-rec
        |match|math-cmd|mod|module
        |not
        |of|open
        |sig|struct
        |then|true|type
        |val
        |when|while|with
        |}

      I give some remarks on variable names.
      If you write \codem{x-1} with the intention of being“expression which subtracts 1 from the variable \codem{x} storing an integer”, you will get an unintended result.
      This is because \codem{x-1} is regarded as a one variable name\footnote{Usually type inspection gives an error “undefined variable \codem{x-1} is used”.
      However, if the variable name \codem{x-1} is used as a variable storing integer, then the situation is very troublesome and it is cause of a bug which is difficult to find.}.
      As a workaround, you should make it a habit of adding spaces before and after binomial operators as \codem{x - 1}.
      
      There are many cases other than \codem{-} which gives an unintended result of token separations by not adding spaces, I strongly recommend to add spaces before and after binomial operators when it is used between expressions.
    }
    +p{
      The bound of variables are done by the \dfn{let-expression} which has the following form\footnote{
        Here \codem{\meta{x}} and \codem{\metasub(${1}){expr}} are “metacharacters” and it does not mean that  the strings such as \codem{x} and \codem{expr1} are written as they are.
        The readers should replace with a suitable things.
        Such “metacharacters” will be appear frequently, so please get used to this.
%        ここにイタリック体で
%        \codem{\meta{x}}とか\codem{\metasub(${1}){expr}}などと書いたのは
%        “メタ文字” であり，
      }.

      \d-codem{
        let \meta{x} = \metasub(${1}){expr} in \metasub(${2}){expr}
      }%

      \codem{\meta{x}} is a name of a variable to be bound and \codem{\metasub(${1}){expr}} and \codem{\metasub(${2}){expr}} are expressions.
      This let expression bound the value as a result of evaluating \codem{\metasub(${1}){expr}} to the variable \codem{\meta{x}} and evaluate \codem{\metasub(${2}){expr}}.
      Namely, in \codem{\metasub(${2}){expr}}, you can use \codem{\meta{x}} as a value as a result of evaluating \codem{\metasub(${1}){expr}}.

      \d-code-and-block(```
        +p{ Answer:
          \show-int(
            let n = (1 + 2) * 3 - 4 in
              n * n * n
          );
        }
      ```)(open Sample in '<
        +p{
          Answer:
          \show-int(
            let n = (1 + 2) * 3 - 4 in
              n * n * n
          );
        }
      >);%

      You can see that an expected value is calculated.
%      あまりにも大したことのない例だが，期待どおり計算できていることがわかる．
    }
    +p{
      Here is a note to readers who are already familiar “procedural” programming such as C programming language or Python.
      The bound is close to the substitution but not the same.
      Variables in \SATySFi; is not “a box one can store values and change the value always”. (It is also common to so-called functional programming such as Ocaml.)
      A more correct intuition is “a value with an alias”.
    }
  >
  +subsection{Basic data}<
    +p{
      Of course \SATySFi; can use data other thatn integers.
      It can use  floating-point numbers, strings, booleans, and length for typesettings.
      I will explain length in \ref-subsection(`length`); and booleans in \ref-subsection(`conditionals`); with an explanation of conditional brunchs.
      Here I will introduce floating-point numbers and strings.
    }
    +p{
      First I am going to introduce the data for decimals, namely \dfn{floating-point numbers}.
      The treatment of floating-point numbers in \SATySFi; follows \dfn{IEEE754} \cite[`IEEE754`];.
      To explain types going ahead, the type of floating-point numbers is \type(Type.float);
      Let us change a paragraph in the above template to \codem{\\show-float} as follows to check the value of floating-point numbers by outputting to PDF.

      \d-code(```
          +p{ Answer: \show-float(42.195); }
      ```);%

      Let us play by changing \codem{42.195} to others as like \codem{\\show-int}.
      Literals for floating-point numbers are written simply as \codem{42.195} and \codem{3.14}.
      At this point, you can not use exponential notation like “\code(`1e-5`);”.
      If the decimal part is \codem{.0}, you can write \codem{5.} instead of \codem{5.0}.
      But you can not omit the integer part even when it is \codem{.0}.
      You can apply addition, subtraction, multiplications and division for floating-point numbers Similarly to integers.
      However you should use \codem{+.} and \codem{\*.}, not \codem{+} and \codem{\*}.

      \d-code-and-block(```
        +p{ Answer: \show-float((1.1 +. 0.7) *. 2.4); }
      ```)(open Sample in '<
        +p{ Answer: \show-float((1.1 +. 0.7) *. 2.4); }
      >);%

      整数値と浮動小数点数との演算は，直接はできない．
      An expression like \codem{1 +. 2.0} gives an type error. (I will explain on types later.)
      When you want to use an expression \codem{\meta{expr}} which will be integers after evaluated, you have to tralnslate it to floting-point numbers by using \codem{float \meta{expr}}:

      \d-code-and-block(```
        +p{ Answer: \show-float((float (1 + 2 * 3 - 4)) *. 2.4); }
      ```)(open Sample in '<
        +p{ Answer: \show-float((float (1 + 2 * 3 - 4)) *. 2.4); }
      >);%

      Note that \codem{float 1 + 2 \* 3 - 4} is regarded as \codem{(float 1) + 2 \* 3 - 4} because the associativity between \codem{float} and successive expressions is stronger (?) than that of binary operators.
      Conversely, to regard an expression \codem{\meta{expr}} evaluated to a floating-point numbers as an integers by rounding the decimal part, you should write \codem{(round \meta{expr})}.

      \d-code-and-block(```
        +p{ Answer: \show-int((round ((1.1 +. 0.7) *. 2.4)) * 2); }
      ```)(open Sample in '<
        +p{ Answer: \show-int((round ((1.1 +. 0.7) *. 2.4)) * 2); }
      >);%

      If the evaluated value of \codem{\meta{expr}} is the infinity, NaN or flat-numbers which is not in type \type(Type.int); after rounding the decimal parts, the evaluated value of \codem{(round \meta{expr})} is undefined.
      By the way, \codem{float} and \codem{round} used here is called \dfn{functions}.
      More general explanation will be given in \ref-subsection(`functions`);.
    }
    +p{
      Next we discuss on strings.
      To output “calculation result” of strings to PDF, let us use \codem{\\show-string} in the above template.

      \d-code(```
          +p{ Answer: [\show-string(`this is a string`);] }
      ```);%

      We play with this template by changing \codem{\`this is a string\`} to some other codes.
      \codem{\[} and \codem{\]} which surrounds \codem{\\show-string( ${\cdots} )\;} is a part of inline-texts and this is just for emphasizing which part is output by \codem{\\show-string}.
      By this, if the end of the output string is a space, we can check that such a spaces is really output to PDF.
    }
    +p{
      As I've already introduced, string literals are written with surrounded by back quotes (\codem{\`}) in \SATySFi;.
      In many programming languages, strings are surrounded by double quotes and special character such as carriage return or double quotes are escaped by the backslash.
      In \SATySFi; there is no notation for escaping.
      Instead of this, the literals only with back quotes are provided.
      How can we include back quote in the strings like “\code(``foo`bar``);”without escaped characters? 
      If you have an experience to use Markdown, then it may be easy to imagine.
      So if back quotes are appeared in the strings, you use two back quotes.
      Then \SATySFi; can recognize the end of the string.
      Let's try to change our template as follows.

      \d-code(```
        +p{ Answer: [\show-string(``foo`bar``);] }
      ```);%

      Then it gives the following output.

      \d-block(open Sample in '<
        +p{ Answer: [\show-string(``foo`bar``);] }
      >);%
      
      In general, when you want to use ${n} adjacent back quotes, you can surround the strings by ${n + 1} back quotes.
    }
    +p{
      The readers who has a bad personality in a godd way may notice some corner cases: If the string contains a backquote at the end, then what we can do?
      The solution is simple.
      If the end of the string has a backquote, then one can add a space between a backquote for string literals and a backquote in the string.
      The spaces at the end of the strings surrounded by backquotes is removed.

      \d-code-and-block(```
        +p{ Answer: [\show-string(`` `bar``);] }
      ```)(open Sample in '<
        +p{ Answer: [\show-string(`` `bar``);] }
      >);%

      You can see that the spaces are removed and the left end of the string is a backquote.
      I know what you are going to think next: What we can do if a space is at the end of the string?
      I can answer this question.
      If you want \SATySFi; not to ignore the more than 0 spaces at the left end of the string, change the left backquotes surronding the string from \codem{\`} to \codem{\#\`}.
      When using two backquotes, add \codem{\#} as \codem{\#\`\`}.
      For spaces at the right end of the string, change  the left backquotes surronding the string from \codem{\`} to \codem{\#\`} similary.
      The way is similar for more than one backquotes.

      \d-code-and-block(```
        +p{ Answer: [\show-string(#`` `bar``);] }
      ```)(open Sample in '<
        +p{ Answer: [\show-string(#`` `bar``);] }
      >);%

      You can see that the spaces are not removed.
      Now you can use string literals freely.
      %これでようやく安心して文字列リテラルが使える．
    }
    +p{
      Now you can write string literals.
      I will explain how to construct strings.
      You can concat the strings by the binary operator \codem{^}.
      The expression \codem{\meta{expr}} evaluted as integers can be changed to decimal strings by \codem{(arabic \meta{expr})}.

      \d-code-and-block(```
        +p{ Answer: [\show-string(
          `The result is `# ^ (arabic ((1 + 2) * 3 - 4)) ^ `!`
        );] }
      ```)(open Sample in '<
        +p{ Answer: [\show-string(
          `The result is `# ^ (arabic ((1 + 2) * 3 - 4)) ^ `!`
        );] }
      >);%

      \codem{arabic} used here is again a function.
      This will be explained in \ref-subsection(`functions`); more precisely.
    }
    +p{
      Note that inline-texts \codem{\{ ${\cdots} \}} and strings are not the same.
      The former contains, for example commands, but the latter is a sequence of unicode points.
      The strings can be changed to inline-texts (which contains equivalent texts, does not contain commands) by the function \codem{embed-string}.
      I will explain on it in \ref-subsection(`functions`);, too.
    }
  >
  +subsection{A fundamental on type systems}<
    +p{
      What will happen if you try to “add a string to an integer”.
      To say from the conclution, such a calculation does not make sense and “you are not allowed to try to do such a calculation” since the type-checkers reject it.
      Try the following example using the first template used for the calculation of integers with \codem{\\show-int}:
%      整数の計算に使った\codem{\\show-int}を含む最初のテンプレートで，
%      試しに以下のように記述して処理してみよう：

      \d-code(```
        +p{ Answer: [\show-int(
          42 + `added string`
        );] }
      ```);%

      Then you will get the following error.

      \console(```
        ! [Type Error] at "test.saty", line 12, characters 9-23:
            this expression has type
              string,
            but is expected of type
              int.
      ```);%

      The file name \code(`test.saty`); and the line count is changed depending on how you write the code.
      Anyway the message points the place where \codem{\`added string\`} is written.
      The error in the above is the \dfn{type error} raised by the type checker of \SATySFi;.
%      その意味するところは（ほぼ直訳だが）
%      「\codem{\`added string\`}という式は\type(Type.string);型の式だが，
%      ここには\type(Type.int);型の式が書かれることが期待されている」だ．
      Here the \dfn{type} which is the most noticeable feature of \SATySFi; appears.
      \footnote{
        The type is very common as a feature of a programming language.
        What should be noticed in \SATySFi; is not to have a type system but have a type system with typesetting system.
%        といっても，プログラミング言語のもつ特徴としては型はごく一般的な概念である．
%        型システムを有していることではなく，
%        型システムを組版処理を行なう処理系に持ち込んだことが
%        \SATySFi;の顕著な特徴なのである．
      }．
      Once I leave such a concrete type error, I will discuss the general theory of types.
%      一旦上のような具体的な型エラーを離れ，型についての一般論の時間にしよう．
      Types are, roughly speaking, “a classification by kinds of values”, or “a classification of expressions by kinds of evaluated values which we can know before”.
%      型とは，非常に大雑把に言えば “値の種類による分類”，さらには
%      “評価した結果どんな種類の値になることが事前にわかっているかに基づく式の分類”
      It is important that we can know a kind of evaluated value “before” evaluation.
%      である．ここで “事前に” と言っているところが非常に重要だ．
%      要するに，“計算を実際に行なわなくともどんな種類の値が結果として出てくるのかが
%      式の字面%\footnote{より正確には抽象構文木である．}
%      だけからわかる”
      Namely one can know a kind of evaluated value only reading an appearance of expressions\footnote{It is an abstract syntax tree, more precisely.} without real evaluation.
%      ような仕組みが型によって確立されているということであり，
      This is a \dfn{type system}.
      The type checker checks consistency of a program by types.
      It checks a program by giving a type to each expression of a program.
    }
    +p{
      Intuitively it is easy to give a type.
      We have a type \type(Type.int); as a type of integers (as appearing in the above type error).
      The integer literal expressions which is a value without an evaluation, such as \codem{1}, \codem{2} and \codem{500000000} has a type \type(Type.int);
      Mover important thing is how to give a type to an expression “which will be calculated” after evaluation.
      For example, an expression of addition \codem{\metasub(${1}){expr} + \metasub(${2}){expr}} is treated by a type system as follows: There is a rule that “if \codem{\metasub(${1}){expr} + \metasub(${2}){expr}} has a certain type, then it should be a type \type(Type.int); and both \codem{\metasub(${1}){expr}} and \codem{\metasub(${2}){expr}} should have a type \type(Type.int);.”
      This is a rough framework of a type system.
      Actually, this is more general framework.
      I will explain on it in the next subsection where I will explain how to give types to functions.
%      本当はもう少し一般性の高い仕組みなのだが，それは次節での函数の型つけの説明に譲る．
    }
    +p{
      Now we go back to a type error before.
      The reason for the error is, to give a type to \codem{\metasub(${1}){expr} + \metasub(${2}){expr}}, we have to give a type \type(Type.int); to \codem{\metasub(${1}){expr}} and \codem{\metasub(${2}){expr}} as explained before.
      However \codem{\metasub(${2}){expr}} is \codem{\`added string\`} which is a string literal.
      Hence it does not have \type(Type.int); (It can have a type \type(Type.string);.)
      Therefore one can not give a type to the expression of the addition and the type checker rejects it.
    }
  >
  +subsection?:(`length`){Length}<
    +p{
      As you have understood a basic things of the type system, let us look at a \dfn{length} and its type \type(Type.length); which is one of a basic data type in typesetting process.
      This is probably data type that you rarely see included in general-purpose programming languages as a feature that cannot be broken down any further.
      As the behavior, the length value is almost like floating-point numbers\footnote{
        Currently, there is no strict specification of how length-related operations should behave.
        If it is not strictly specified, how the lines are broken will be “processor dependent”.
        In the future, it may be better to specify the behavior.
        However, for now, there is only available implementation for \SATySFi; is the one implemented by the author (and the ones forked by others and modified the parts not related to the length handling).
        Therefore we are not concerned about it.
        In the current implementation, the length is internally expressed as a floating-point number in DTP points (see below).
      }, but to prevent “meaningless calculations” such as “multiplying lengths by each other and use the result as the length” cannot be easily performed
      Namely, the Floating-point numbers are distinguished from floating-point numbers in terms of type not to pass such a calculation.
      A constant length literal is written as \codem{2.5cm}, \codem{-1inch}, etc as the following syntax:
%      型システムの基礎を把握してもらったところで，
%      組版処理上基礎的なデータのひとつである\dfnje{長さ}{length}と
%      その型である\type(Type.length);型を紹介しよう．
%      これはおそらく汎用のプログラミング言語には
%      それ以上分解できない機能として搭載されているのをまず見ない
%      データだろう．
%      長さの値は振舞いの上ではほぼ浮動小数点数のようなものではある\footnote{
%        現状，長さに関する演算がどのように振舞うかは厳密には規定しない．
%        厳密に規定しなければどのように行分割されるかが “処理系依存” になってしまうので
%        将来的には規定した方が望ましいのであろうが，
%        今のところ公開されている\SATySFi;の処理系は
%        著者が実装した1つ（およびそれを他者がforkし長さの扱いに関係しない箇所を改変したもの）
%        しかないと思われるのでひとまず気にしなくてよい．
%        なお，現在の処理系の実装では（後述する）DTPポイント単位の
%        浮動小数点数で内部的に表現されている．
%      }が，
%      “長さ同士を乗算したものを長さとして使う” といった
%      “意味をなさない計算” が安易にはできないように，
%      つまりそういった計算をしようとする記述が型検査を通らないように，
%      浮動小数点数とは型の上で区別されている．
%      長さの定数リテラルは，\codem{2.5cm}とか\codem{-1inch}といった，
%      次に該当する構文で書く：
      \d-codem{
        \meta-or{|-||}\meta-or{|〈non-negative floating number〉|〈non-negative integer〉|}〈unit〉
      }%

      Here the \codem{unit} part is a string with the same rules as the variable name.
      This whole thing is a single token that forms a constant literal of length.
      There should not be any spaces between the negative sign and the numeric part, or between the numeric part and the unit.
      The following pre-defined (absolute, independent of the "situation") are allowed as concrete units.
%      ただし，\codem{〈単位〉}の部分は変数名と同一の規則の文字列である．
%      これ全体が長さの定数リテラルをなす1トークンであり，
%      負の符号と数値部分の間や数値部分と単位の間に空白文字を入れたりしてはいけない．
%      具体的な単位については，あらかじめ定義された以下の
%      （“状況” に依存しない，絶対的な）単位のみが使える：

      \listing{
        * \codem{mm}：\quad;
%          ミリメートル
          millimeter

        * \codem{cm}：\quad;
%          センチメートル
          centimeter

        * \codem{inch}：\quad;
          \dfn{international inch} (a unit that strictly defines ${1\math-unit!{inch}} as ${2.54\math-unit!{cm}}.)
%          \dfnje{国際インチ}{international inch}（${1\math-unit!{inch}}を
%          厳密に${2.54\math-unit!{cm}}と定めた単位）

        * \codem{pt}：\quad;
          \dfn{DTP point}(${1\math-unit!{pt}}) (a unit that strictly defines ${1\math-unit!{pt}} as ${\paren{1/72}\math-unit!{inch}}.)
%          \dfnje{DTPポイント}{DTP point}（${1\math-unit!{pt}}を
%          厳密に${\paren{1/72}\math-unit!{inch}}と定めた単位）
      }%

      Note that you cannot use relative length units such as em or ex, which depend on the “current font size”.
      Of course, there is a way to specify the length as em units practically, which will be explained later\footnote{Speaking very ahead of time, such a process is achieved using the primitive \codem{get-font-size}}.
%      emやexなどといった，“現在の文字サイズ” に依存する
%      相対的な長さの単位は使えないことに注意されたい．
%      勿論実質的にem単位で長さを指定する方法は存在し，
%      それについては後々わかることになる\footnote{
%        大幅に先走って述べておくと，そのような処理は
%        \codem{get-font-size}というプリミティヴを用いて実現する．
%      }．
      A more tricky point is the definition of the unit “point”.
      Historically, the unit called “point” has been given many different definitions.
      Here are some of the most common definitions:
%      さらに引っかかりやすいポイントは，ポイントという単位の定義だ．
%      “point” と呼ばれる単位には歴史的に様々な定義が与えられてきた．
%      代表的なものを掲げる：
      \listing{
        * \dfn{Didot’s point }(1783): \quad;
          Exactly ${\paren{1/72}} times the French inch based on the pied du Roi (royal foot).
%        * \dfnje{Didotポイント}{Didot’s point}（1783年）：\quad;
%          pied du Roi（royal foot，王のフィート）に基づくフランスのインチの厳密に${\paren{1/72}}倍．

        * American Point (1886): \quad;
          Exactly ${0.013837} times inch.
%        * アメリカンポイント（1886年）：\quad;
%          インチの厳密に${0.013837}倍．

        * Based on JIS Z 8305 (1962): \quad;
          Exactly ${0.3514\math-unit!{mm}}
%        * JIS Z 8305に基づくもの（1962年）：\quad;
%          厳密に${0.3514\math-unit!{mm}}．

        * \TeX; points \code(`pt`); (1982): \quad;
          Exactly ${\paren{1/72.27}} times international inch.
%        * \TeX;ポイント\code(`pt`);（1982年）：\quad;
%          国際インチの厳密に${\paren{1/72.27}}倍．

        * Didot points in \TeX; \code(`dd`); (1964): \quad;
          Exactly ${\paren{1157/1238}} times the \TeX; point.
%        * \TeX;でのDidotポイント\code(`dd`);（1964年）：\quad;
%          \TeX;ポイントの厳密に${\paren{1157/1238}}倍．

        * DT poit (1984): \quad;
          Exactly ${\paren{1/72}} times the international inch.
          It is introduced in the \dfn{PostScript} \cite[`PostScript`]; specification, which is also called \dfn{PostScript point}.
          \code(`pt`); in CSS, and \dfn{big point} \code(`bp`); in \TeX; are also the same as this\footnote{
            However, the length in \TeX; is expressed as an integer multiple of \dfn{scaled point}\code(`sp`); which is exactly ${\paren{1/65536}} times the length of the \TeX; point, and the big point is also treated as exactly ${\paren{65781/65536}} times the length of the \TeX; point.
            Hence there is a difference between the definition and the implementation.
            However, since \code(`sp`); is on the order of ${10^{-6}\math-unit!{mm}}, there is no need to worry about rounding error for this unit in visual representation.
          }.
%        * DTPポイント（1984年）：\quad;
%          国際インチの厳密に${\paren{1/72}}倍．
%          \dfn{PostScript} \cite[`PostScript`];
%          の仕様で導入され，\dfnje{PostScriptポイント}{PostScript point}とも呼ばれる．
%          CSSで扱われる\code(`pt`);，および
%          \TeX;の\dfnje{ビッグポイント}{big point} \code(`bp`);も，
%          これに等しい\footnote{
%            ただし，\TeX;での長さの扱いは
%            \dfnje{スケールドポイント}{scaled point} \code(`sp`);
%            という\TeX;ポイントの厳密に ${\paren{1/65536}}倍の長さの整数倍として表現され，
%            ビッグポイントも\TeX;ポイントの
%            厳密に ${\paren{65781/65536}}倍として扱われているので，
%            定義と実装で差がある．
%            といっても\code(`sp`);は ${10^{-6}\math-unit!{mm}}のオーダーなので，
%            視覚表現上はこの単位に対する丸め誤差を気にする必要がない．
%          }．
%

      }%

      We adopted DTP points as the definition of \codem{pt} as it has been established as the de facto standard for compatibility across CSS, PostScript, PDF (and \code(`bp`); units, but \TeX;), etc.
%      CSS，PostScript，PDF（および，\code(`bp`);という単位だが，\TeX;）
%      などに広くまたがって互換性に優れた
%      デファクトスタンダードとして確立されていることを鑑み，
%      \SATySFi;は\codem{pt}の定義としてDTPポイントを採用した．
    }
    +p{
      The expressions for basic calculations on length is as follows:
%      長さに関する基礎的な演算を行なう式は次のとおりである：

      \listing{
        * \codem{\metasub(${1}){l} +' \metasub(${2}){l}}：\quad;
          addition of lengths.
%          長さ同士の加算．

        * \codem{\metasub(${1}){l} -' \metasub(${2}){l}}：\quad;
          Subtraction of lengths.
%          長さ同士の減算．

        * \codem{\meta{l} \*' \meta{r}}：\quad;
          It takes the length \codem{\meta{l}} and the floating point number \codem{\meta{r}}, and returns the length of \codem{\meta{l}} multiplied by \codem{\meta{r}}.
%          長さ\codem{\meta{l}}と浮動小数点数\codem{\meta{r}}を受け取り，
%          \codem{\meta{l}}を\codem{\meta{r}}倍した長さを返す．

        * \codem{\metasub(${1}){l} /' \metasub(${2}){l}}：\quad;
          Returns a floating-point number that is “how many times” the length \codem{\metasub(${1}){l}} is greater than the length \codem{\metasub(${2}){l}}.
%          長さ\codem{\metasub(${1}){l}}が
%          長さ\codem{\metasub(${2}){l}}の
%          “何倍の長さであるか” の浮動小数点数を返す．
      }%
    }
  >
  +subsection?:(`functions`){函数定義}<
    +p{
      %大抵のプログラミング言語には，頻出する計算手順に名前をつけ，
      %その計算手順を1箇所にまとめて記述する方法が備わっている．
      Most programming languages have a way of naming computational procedures occurring frequently and writing them in one place. 
      %多くの言語と同様に，\SATySFi;では\dfnje{函数}{function}がその役割を担う\footnote{
      %  函数のほかには，\dfn{Fortran90}などの言語に見られるように
      %  \dfnje{サブルーティン}{subroutine}と呼ばれる機構がこの役割を担っている言語もある．
      %}．
      As in many languages, \dfn{function} has that role with \SATySFi;\footnote{
        In addition to the function, as seen in languages such as \dfn{Fortran90}, some languages have a mechanism called \dfn{subroutine} that has this role.
      }.
      %函数は，何らかの値を受け取り，それを加工して新たな値をつくる処理である．
      Functions are procedures which takes some values, processes it and make a new value.
      %例として，円単位の金額を整数で受け取り，
      %それをドル単位に換算する函数\codem{to-dollar}を定義してみよう．
      As an example, let define a functiorn \codem{to-dollar} which takes an ammount in yesn as an integers and converts it to dollers.
      %レートはひとまず9月24日19時23分(UTC)に基づいて${1}ドルを${112.73}円とする．
      The rate is with ${1} dollar being ${112.73} yen, based on 19:23 (UTC), September 24.
      %これは以下のようにして定義できる：
      This can be defined as follows.

      \d-code(```
        let to-dollar m-yen =
          let rate = 112.73 in
            (float m-yen) /. rate
        in
          (continuation expression)
      ```);%

      % 函数の定義もlet式を用いて行なうのである．
      We define the functions using let-expression.
      % ここで登場する\codem{m-yen}は\dfn{仮引数}
      % または単に\dfn{引数}と呼ばれるもので，
      % 函数\codem{to-dollar}の受け取る値が格納される変数である．
      \codem{m-yen} appearing here is called \dfn{formal argument} or \dfn{parameter} and is a variable which stores the value received by the function \codem{to-dollar}.
      % ここで例示した\codem{to-dollar}はひとつだけ引数をとる函数だが，
      % 一般には任意に正整数個とれる．
      The example shown here, \codem{to-dollar}, is a function that takes only one argument. In general, it can take any number of positive integers.      % 函数定義は，次のような構文によって為される：
      You can define the functions by the following syntax:

      \d-codem{
        let \meta{f} \metasub(${1}){x} ${\cdots} \metasub(${n}){x} =
          \metasub(${1}){expr}
        in
          \metasub(${2}){expr}
      }%

      %\codem{\meta{f}}が定義したい函数に与える名前であり，
      %各\codem{\metasub(${i}){x}}は第 ${i} 引数である．
      \codem{\meta{f}} is a name of the function which you want to define and each \codem{\metasub(${i}){x}} is the ${i}-th parameter.
    }
    +p{
      %さて，上で定義した函数\codem{to-dollar}を実際に使ってみよう．
      Let's try to use the function \codem{to-dollar} defined above in practice.
      %函数の定義は，パッケージの読み込みの記述から\codem{document}までの間の部分で行なえる．
      The definition of the function can be done in the part between the loading packages and \codem{document}.
      % すなわち，以下のようになる：
      That is, we have the following.

      \d-code(```
        @require: stdjareport

        let-inline \show-int n = embed-string (arabic n)
        let-inline \show-float x = embed-string (show-float x)
        let-inline \show-string s = embed-string s
        in

        let to-dollar m-yen =
          let rate = 112.73 in
            (float m-yen) /. rate
        in

        document (|
          （以降略）
      ```);%

      % それでは実際に\codem{to-dollar}を使って円単位の金額をドル単位に換算してみよう．
      Let's try to convert yen amounts into dollars using \codem{to-dollar}.
      % 函数\codem{\meta{f}}に式\codem{\meta{expr}}の計算結果を渡したいときは
      % \codem{\meta{f} \meta{expr}}と書く．
      When you want to pass the result of calculation of the expression \codem{\meta{expr}} to the function \codem{\meta{f}}, you write \codem{\meta{f} \meta{expr}}.
      %これを函数\codem{\meta{f}}の式\codem{\meta{expr}}への\dfnje{適用}{application}
      %とか式\codem{\meta{expr}}による函数\codem{\meta{f}}の\dfnje{呼び出し}{call}
      %と呼ぶ．
      This is called an \dfn{application} of the function \codem{\meta{f}} to the expression \codem{\meta{expr}} or a \dfn{call} of the function \codem{\meta{f}} by the expression \codem{\meta{expr}}.
      %また，ここで評価結果が\codem{\meta{f}}に渡される式\codem{\meta{expr}}のことを
      %\codem{\meta{f}}の\dfn{実引数}と呼ぶ．
      Also, the expression which the evaluation result is passed to \codem{\meta{f}} is called an \dfn{argument} of \codem{\meta{f}}.
      % やや厄介なことに，仮引数だけでなくこの実引数も単に\dfn{引数}と呼ばれることが多い．
      Somewhat annoyingly, this argument as well as a formal argument is often referred to simply as \dfn{parameter}.
      % しかし「引数」が仮引数の意であるか実引数の意であるかは
      % ほとんどの場合使用されている文脈から判断できるので，
      % 特に違いを強調する必要のない場合は両者ともに引数と書くことにする．
      However, whther the "parameter" means a formal argument or an argument can be determined from the context in most cases, both are written as parameters when we do not need to emphasis the differences.
      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      % よくわからないので引数→parameter，仮引数→formal argument，実引数→argumentとしてみた．後で調べる．
      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    }
    +p{
      % 函数\codem{\meta{f}}の式\codem{\meta{expr}}への適用は，次のような流れで評価される：
      The application of the function \codem{\meta{f}} to \codem{\meta{expr}} is evaluated in the following flow:

      \listing{
        %* 実引数\codem{\meta{expr}}が評価されて値\codem{\meta{value}}になる．
        * The argument is evaluated and becoms the value \codem{\meta{value}}.

        %* 函数\codem{\meta{f}}の定義
        %  \codem{let \meta{f} \meta{x} = \meta{e} in ${\cdots}}
        %  が “思い返される”．
        * THe definition of the function \codem{\meta{f}} \codem{let \meta{f} \meta{x} = \meta{e} in ${\cdots}} is “recalled”.

        %* 仮引数\codem{\meta{x}}が\codem{\meta{value}}に束縛された下で
        %  “定義の本体” である式\meta{e}が評価され，その結果が適用の式全体の評価結果となる．
        * The expression \meta{e} which is the “body of the definition” is evaluated under the constraint that the formal argument \codem{\meta{x}} is binded to \codem{\meta{value}}
        and the result is the result of the evaluation of the entire expression.
      }%

      % 不正確ながら大雑把に言ってしまえば，
      % 函数定義中の仮引数が実引数で置き換えられたものを計算するのが函数適用である．
      To put it roughly but inaccurately, the application of a function is to compute the substitution of arguments for formal argument in a definition of a function.
      % さて，実際に\codem{to-dollar}を適用したのが以下だ：
      The actual application of \codem{to-dollar} is as follows:
      
      \d-code-and-block(```
        +p{ Answer: \show-float(to-dollar 10000); }
      ```)(open Sample in '<
        +p{ Answer: \show-float(to-dollar 10000); }
      >);%

      %やはり大雑把に言えば，\codem{to-dollar}の “定義本体” の中の\codem{m-yen}がすべて
      %\codem{10000}に置き換わったものの計算結果が出ているわけである．
      Roughly speaking again, the result of calculations of the "definition body" of \codem{to-dollar} replacing all of the \codem{m-yen} with \codem{10000} is obtained.
      
      % というわけで10000円は大体88.7ドルくらいであることが計算できた．
      So we can calculate that 10000yen is about 88.7 dollers.
    }
    +p{
      % 函数それ自体にも，整数などと同様に型がつけられる．
      Then function itself has, like integers, types.
      %\type(Type.tymtausub ${1});型の引数をとって
      %\type(Type.tymtausub ${2});型の値を返す函数には
      % \type(Type.(tymtausub ${1} --> tymtausub ${2}));
      %という型がつくと定められている．
      The type of the function which takes a parameter of the type \type(Type.tymtausub ${1}); and returns a value of the type \type(Type.tymtausub ${2}); is defined to be \type(Type.(tymtausub ${1} --> tymtausub ${2}));.
      %例えば，上で定義した\codem{to-dollar}は
      %\type(Type.(int --> float));型をもつ．
      For example, \codem{to-dollar} defined as above has the type \type(Type.(int --> float));.
      %このことを以降

      %\val({to-dollar})(Type.(int --> float));%

      %とコロン（${:}）を挟んで式とそれにつく型を並べることで表記する．
      This will be denoted by \val({to-dollar})(Type.(int --> float)); with a colon (${:}) between the expression and the type attached to it.
    }
    +p{
      さて，引数が1個の函数はよいとして，複数の引数をとる函数も
      同様の例を通じて説明する．
      先ほどの\codem{to-dollar}は交換のレートが決め打ちされていた．
      今度はレートも引数にして，その都度変えられるようにしてみたい．
      その定義が以下である：

      \d-code(```
        let to-dollar-2 rate m-yen =
          (float m-yen) /. rate
      ```);%

      レート\codem{rate}が第1引数に，日本円の額面\codem{m-yen}が第2引数になるように改めたのである．
      さて，9月26日16時44分 (UTC) のレートは${1}ドル${112.95}円であった．
      このレートであらためて計算してみよう．
      引数が ${n} 個あるとき，函数適用は
      \codem{\meta{f} \metasub(${1}){expr} ${\cdots} \metasub(${n}){expr}}
      という形で書く：

      \d-code-and-block(```
        +p{ Answer: \show-float(to-dollar-2 112.95 10000); }
      ```)(open Sample in '<
        +p{ Answer: \show-float(to-dollar-2 112.95 10000); }
      >);%
    }
    +p{
      ところで，引数が複数個ある函数はどのような型がつくのだろう？\quad;
      結論から言うと，引数を ${n} 個とり，各第 ${i} 引数の型が\type(Type.tymtausub ${i});，
      返り値の型が\type(Type.tymtau);であるような函数には

      \quote{
        \type(Type.(tymtausub ${1} --> (of-math ${\cdots} --> (tymtausub ${n} --> tymtau))));
      }%

      という型がつく．例えば上で定義した\codem{to-dollar-2}は
      \type(Type.(float --> (int --> float)));という型をもつという具合である．
      この矢印が連なった型は実は新たな記法などではなく，
      括弧を省略せずに書くと

      \quote{
        \type(Type.(tymtausub ${1} --> (synt-paren (tymtausub ${2} -->
          (synt-paren (of-math ${\cdots} --> (synt-paren (tymtausub ${n} --> tymtau))))))));
      }%

      という型である．つまり
      “矢印で構築される函数の型\type(Type.(tymtau --> tymtaup));の
      \type(Type.tymtaup);の側がさらに函数の型になっている” という構造が
      繰り返されてできているのが上記の型なのである．
      だが，どうして ${n} 引数函数の型がこのように表されるのだろうか？\quad;
      これは次のような考察に基づくものだ：

      \quote{
        \type(Type.tymtausub ${1});型の第1引数と
        \type(Type.tymtausub ${2});型の第2引数を受け取って
        \type(Type.tymtau);型の値を返す函数は，
        \type(Type.tymtausub ${1});型の引数を受け取って
        「\type(Type.tymtausub ${2});型の引数を受け取って
        \type(Type.tymtau);型の値を返す函数」を返す函数ともみなせる．
      }%

      これはいわゆる函数型言語が基盤とする理論の中でも初歩となる重要な点で，
      この考察に基づく “変換” を\dfnje{カリー化}{currying}と呼ぶ．
      このことは次に説明する\dfnje{部分適用}{partial application}を
      念頭に置くととても自然に理解できる．
      部分適用とは，簡単に言えば “一部の引数しか渡さないこと” である．
      先ほど定義した\codem{to-dollar-2}に，
      第1引数であるレートの値のみ渡して部分適用することにより
      別の函数を定義してみよう：

      \d-code(```
        let to-dollar-par = to-dollar-2 112.73
      ```);%

      この\codem{to-dollar-par}は
      「日本円での額面を受け取り，それをレート${112.73}円/ドルに基づいてドルの額面にして返す函数」
      であり，型として\type(Type.(int --> float));をもつ．
      \type(Type.(int --> string));型の函数に引数として\type(Type.int);型を渡すと
      返り値の型が\type(Type.string);型であるのと全く同様に，
      \type(Type.(float --> (synt-paren (int --> float))));型の\codem{to-dollar-2}に
      \type(Type.float);型の式を渡す記述だから\type(Type.(int --> float));型なのである．
      こうして定義した\codem{to-dollar-par}は，
      最初に掲げた\codem{to-dollar}と等価な振舞いをする函数になっている．

      また，部分適用と対応するように，実は複数の実引数の適用

      \d-codem{
        \meta{f} \metasub(${1}){expr} ${\cdots} \metasub(${n}){expr}
      }%

      も，括弧を略さずに書くと

      \d-codem{
        (((\meta{f} \metasub(${1}){expr}) \metasub(${2}){expr}) ${\cdots} ) \metasub(${n}){expr}
      }%

      である．これは函数適用\codem{\metasub(${1}){expr} \metasub(${2}){expr}}に於いて
      \codem{\metasub(${1}){expr}}が\type(Type.(tymtau --> tymtaup));型を，
      \codem{\metasub(${2}){expr}}が\type(Type.(tymtau));型をもつことが
      検査されることから考えると自然だろう．
      平均的な型システムの入門的解説に比べるとかなり駆け足になってしまったが，
      以上が函数につけられる型と部分適用の仕組みだ．
    }
    +p{
      ところで，これもいわゆる函数型言語が基盤とする理論としては重要な点なのだが，
      函数はいちいちlet式で名前をつけて扱う必要はない．
      例えば，上でlet式で定義した\codem{to-dollar-2}は
      \codem{to-dollar-2}と名前をつけずとも以下のように\dfn{無名函数}\footnote{
        理論的には\dfnje{ラムダ抽象}{${\lambda}-abstraction}と呼ばれるものである．
      }で書ける：

      \d-code(```
        (fun rate m-yen -> (float m-yen) /. rate)
      ```);%

      勿論この例ではわざわざこう書く必要はないのだが，
      後述する高階函数では役立つことが多い．
      「役立つことが多い」などと，
      あたかも無名函数が “後から言語機能に足された瑣末なもの” であることを
      示唆するかのような言い方になってしまったが，
      実はこの無名函数はlet式による函数の定義よりも言語機能として基盤にあるものだ．
      函数を定義するlet式

      \d-codem{
        let \meta{f} \metasub(${1}){x} ${\cdots} \metasub(${n}){x} =
          \metasub(${1}){expr} in \metasub(${2}){expr}
      }%

      は，実は以下の糖衣構文にすぎない：

      \d-codem{
        let \meta{f} = (fun \metasub(${1}){x} ${\cdots} \metasub(${n}){x} -\>
          \metasub(${1}){expr}) in \metasub(${2}){expr}
      }%

      つまり，前者は処理系で内部的に（構文解析が終わり，型検査が始まる前に）
      後者に変換されているのである．
      後者のlet式は\ref-subsection(`variables`);で最初に紹介したlet式そのものである．
      すなわち，函数定義は単に変数束縛の一種だったのである．
      “函数” と “変数” の垣根がないことは，
      \SATySFi;が拠り所とするML系言語の重要な特徴である\footnote{
        いわゆる函数型言語にあっても，“函数” と “変数” とが
        別個の概念としてある言語は存在する．
        \dfn{Common Lisp}などが有名である．
      }．
      ちなみに，もっといえば

      \codem{
        (fun \metasub(${1}){x} ${\cdots} \metasub(${n}){x} -\>
          \meta{expr})
      }%

      も

      \codem{
        (fun \metasub(${1}){x} -\> (fun \metasub(${2}){x} -\> ${\cdots} (fun \metasub(${n}){x} -\>
          \meta{expr}) ${\cdots}))
      }%

      の糖衣構文である．これは先ほど部分適用で説明したこととも対応しており，
      要するに ${n} 引数をとる函数とは “1引数函数が ${n} 重入れ子になったもの”
      である，ということだ．
    }
    +p{
      すでに述べたが，浮動小数点数や文字列などのデータの説明で登場した
      \codem{arabic}，\codem{float}，\codem{round}は，
      それぞれ以下のような型をもつプリミティヴの函数である：

      \listing{
        * \codem{arabic} : \type(Type.(int --> string));
        * \codem{float} : \type(Type.(int --> float));
        * \codem{round} : \type(Type.(float --> int));
      }%

      函数につく型については上記の説明ですでによく把握されているだろうから，
      それぞれにこのような型がつくことはもはや当然のように感じられるだろう．
    }
    +p{
      さらには，2項演算子も実は函数である．
      \codem{\metasub(${1}){expr} + \metasub(${2}){expr}}は
      実は\codem{(+) \metasub(${1}){expr} \metasub(${2}){expr}}
      という函数適用の糖衣構文であり，2項演算子\codem{+}の正体は
      \codem{(+)}という3トークンからなる特殊な名前をもつ変数なのである．
      \codem{(+)}は\type(Type.(int --> (int --> int)));という型をもち，
      それゆえに\type(Type.(int));型のつかない引数を与えると
      型検査器にエラーを返されていたのである．
      さらに，2項演算子は（通常の変数名の函数と同様に）自分で定義することもできる．
      使える名前は，
      \codem{\meta-or{|+|-|\*|/|^|\&|\||!|:|=|\<|\>|~|'|.|?|}}を
      \codem{\meta{opsymb}}と表すとして

      \listing{
        * \codem{\meta-or{|\*|/|}\meta-star{\meta{opsymb}}}
        * \codem{\meta-or{|+|-|}\meta-star{\meta{opsymb}}}
        * \codem{^\meta-star{\meta{opsymb}}}
        * \codem{\meta-or{|=|\>|\<|}\meta-star{\meta{opsymb}}}
        * \codem{\&\meta-plus{\meta{opsymb}}}
        * \codem{\|\meta-plus{\meta{opsymb}}}
      }%

      にマッチするもののうち，以下に該当しないものである\footnote{
        \codem{--}は実質的に使われなくなっているが，
        歴史的経緯から特殊なトークンとして残存している．
      }：

      \tokens{|=|--|-\>|}%

      結合の強さは先に挙げたものほど強いとする．
      いずれも左結合である．
    }
  >
  +subsection?:(`conditionals`){真偽値と条件分岐}<
    +p{
      真偽値は “正しいか正しくないか” を表すデータであり，\type(Type.bool);型をつけて扱う．
      \type(Type.bool);型のつく式はおおよそ “命題” に対応し，
      \type(Type.bool);型の値としては
      真に対応する ${\term!(Term.truev)} と
      偽に対応する ${\term!(Term.falsev)} との2種類のみがある．
    }
    +p{
      真偽値に関連する言語機能として，
      “何が成り立っているかによってその先の処理を変える” 記述，
      すなわち\dfnje{条件分岐}{conditional branching}がある．
      例として整数の絶対値函数\codem{abs}を定義してみよう：

      \d-code(```
        let abs n =
          if n < 0 then - n else n
      ```);%

      ここで使われる
      \codem{if \metasub(${0}){expr}
        then \metasub(${1}){expr} else \metasub(${2}){expr}}
      が条件分岐に使われる\dfnje{if式}{if-expression}であり，
      直観的には
      「\metasub(${0}){expr}が成り立つならば\metasub(${1}){expr}を，
      そうでないならば\metasub(${2}){expr}を評価する」
      を意味する．
      型つけの規則としては，
      \codem{\metasub(${0}){expr}}は\type(Type.bool);型であることと，
      \codem{\metasub(${1}){expr}}と\codem{\metasub(${2}){expr}}とに
      同一の型がつくことが要請される．
      ここでの例は，整数を比較する2項演算子\codem{\<}を用いて
      与えられた引数が\codem{0}未満であるかどうかを判定しており，
      負の値であった場合は符号を反転し，非負の値であった場合はそのまま返す，
      ということを記述している．
      ちなみに，条件分岐の話とは関係ないが，
      注意深い人は\codem{- n}という部分が新しい構文であることに気づいただろう．
      これは\codem{-}という名前の2項演算子のみに与えられた特殊な機能で，
      大雑把に言えば “左側の引数を省略した場合は\codem{0}として扱う” というものだ．
      要するに符号の反転を自然に書くための機能である\footnote{
        浮動小数点数用の\codem{-.}や長さ用の\codem{-'}には，
        この機能は現状備わっていない．将来的に追加したいとは考えている．
      }．ともあれ，この\codem{abs}の動作を確認してみる：

      \d-code-and-block(```
        +p{ Answer: \show-int(abs (abs (1 - 2) * 3 - 4)); }
        +p{ Answer: \show-int(abs (abs (1 + 2) * 3 - 4)); }
      ```)(open Sample in '<
        +p{ Answer: \show-int(abs (abs (1 - 2) * 3 - 4)); }
        +p{ Answer: \show-int(abs (abs (1 + 2) * 3 - 4)); }
      >);%
    }
    +p{
      論理演算として
      選言\codem{\|\|} : \type(Type.(bool --> (bool --> bool)));，
      連言\codem{\&\&} : \type(Type.(bool --> (bool --> bool)));，
      否定\codem{not} : \type(Type.(bool --> bool));
      などが用意されており，これを用いてより複雑な条件の指定ができる．
      最初から使える種々の演算は\ref-subsection(`arithmetic`);に掲載したので参照されたい．
    }
  >
  +subsection{型システムと型推論の恩恵}<
    +p{
      式に型がつくことで，その式を評価しても
      “値の種類に由来するエラー” は起きないということが保証される．
      というか，型システムはこういったエラーを
      プログラムを評価せず事前に検出して弾くためにあるわけである．
      型なしの言語（いわゆる動的型つき言語\footnote{
        「動的型」と言ったときの「型」は，
        ここで説明した型の概念とは似て非なるもので，
        “実行時にデータの種類を示すものとして値についているタグ”
        であることに注意されたい．
        繰り返しになるが，この本で使用しているのと同様の意で
        「型」と言った時は “式に対して事前にわかる分類”
        である．動的型との混同を避けて
        俗に静的型と呼ばれることもある．
        歴史的には動的型を指して「型」という語を使う方が
        ずっと後発の用法である．
      }）に馴染みの深い読者なら，もしかすると
      「静的型を入れず，
      整数値に文字列を足す処理が書かれたら前者を十進文字列にして
      文字列結合にするように\codem{+}を定義すればよいのでは？\quad;
      逐一\codem{arabic}で整数値を文字列値へ変換する処理を
      明示的に書く必要もないし楽になるだろう」
      などと考えるかもしれない．
      だが，
      \codem{\metasub(${1}){expr} + \metasub(${2}){expr}}
      の形の式の計算結果が整数値にも文字列値にもなりうるというのは
      そんなに “うれしいこと” ではない．
      式に型をつけないという言語設定を仮定した下で，次のような函数を考えよう：

      \d-code(```
        let f x =
          let y = 42 + x in
            y / 2
      ```);%

      型なしの言語だったりして，
      整数値と文字列値の加算が許容されるとしよう．
      このとき，上記の\codem{f}に渡される\codem{x}の “値の種類” によっては，
      除算\codem{y / 2}に於いて
      \codem{y}が文字列値など整数値でない場合も扱わねばならないことになる．
      除算の定義をどうするか，ここで2通りの選択肢がある：

      \listing{
        * 整数値以外が左側にきた場合は実行時エラーとする．

        * 整数値以外が左側にきた場合，結果を必ず\codem{0}にしたり，
          何も処理せずその値を返したりと，
          とにかく何かしらそれらしい値を返して実行時エラーにはしない．
      }%

      前者を採用した場合，
      これはまさに型システムを入れることで除外したかった
      “値の種類による実行時の破綻” だ．
      「この実行時エラーを許容してもよいから静的に型をつけたくない」
      という主義の人もいるかもしれないが，
      ほとんどの場合その決断は割りに合わないと言ってよい．
      型なしの言語で数千行規模のプログラムを書くと
      （静的型つきの言語で書いた場合に比べて）
      急速に保守が困難になることは想像に難くないし，
      経験的にもそうであることが多いはずだ．
      もし貴方が数千行規模のプログラムを型なしの言語で書いて保守しており，
      かつ特に苦労していると思っていないなら，
      それは単に型なし言語のデバッグの労苦に飼い慣らされていて，
      静的型つきの言語の世界観から見れば大部分は要らぬ苦労をしているだけ，
      という可能性は非常に高い．

      一方で後者を採用した場合，
      計算が失敗することはないが，
      些細な間違いに対してもデバッグが非常に困難になる．
      どこで意図しない計算が生じているか
      事細かに追わないとわからないからだ．
      特に組版処理のように “扱う値の種類” が多い場合，
      “種類の違い” による意図しない計算は生じるリスクが大きく，
      致命的に修正困難な状況に陥りやすいだろう．
      要するに，“値の種類によらず計算に失敗しないようにする” ことも
      “そんなに嬉しくない” のである．
    }
    +p{
      とにかく，人間はプログラムを書く際にはひたすら間違い続ける．
      しかもその間違いは，かなりしょうもないものであることが経験的に多そうだ．
      型検査器は人間の犯すミスのうち或る種の不整合を丁寧にも事細かに指摘してくれる．
      決してお節介なお婆さんではない．
      「“式の種類” に関して不整合のあるプログラムを書いたときに
      型検査器がその不整合を教えてくれ，
      それに基づいて該当箇所をスムーズに修正できる」という利点は，
      「“異なる種類” への値の変換を\codem{arabic}のような形で明示的に書かなければならない」
      という多少の厄介さを補ってあまりがありすぎるほどの恩恵である．
      また，これは非常に誤解が多いのだが，
      プログラムに静的に型をつけるのに
      \dfnje{型註釈}{type annotation}，
      つまり各変数にどのような型をつけるかを明示した註釈が必要なわけでは
      必ずしもない\footnote{
        「静的型つきの言語は逐一変数につく型を書かないといけないから面倒」
        という誤解は，おそらくC言語のような型註釈が省略できない
        （或る意味特殊な）静的型つき言語の存在によるところが大きそうだ．
        一般に静的型つき言語で変数の型註釈が省略できないわけでは決してない．
      }．
      適切に型システムを設計すれば，与えられたプログラムが “整合している” 限り，
      全部または一部の変数にどのような型がつくか，型推論で求められるのである．
      特に\SATySFi;を含めOCaml，F\#，Standard ML，Haskellなど多くの言語の型システムが
      その理論的基盤としている
      \dfn{Damas–Hindley–Milner多相}\footnote{
        \dfn{Hindley–Milner多相}，\dfn{Damas–Milner多相}，
        \dfn{let多相}，\dfn{冠頭多相}などとも呼ばれる．
      } \cite[`Hindley1969`; `Milner1978`];は，
      型推論が\dfnje{完全性}{completeness}をもつ，
      すなわち変数に一切型註釈のない式に対しても
      必ずその式につく “最も一般的な型” である\dfnje{主要型}{principal type}
      が存在してかつそれを求めるアルゴリズムが知られているという性質があり，
      それゆえに特に\SATySFi;やOCamlでは
      よほど複雑な機能を使わない限り基本的に型註釈を書かなくてよいという状況が達成されている．
      つまり型註釈が現実的にプログラマの手を煩わせることはほとんどない．
      むしろ型註釈が省略できすぎるので，
      （2週間後の自分が見てプログラムを読めなくなることのないように）
      型検査器からすればなくてもよい型註釈を可読性のために入れるくらいである\footnote{
        Haskellはlet多相を基盤としていながらも
        \dfnje{型クラス}{typeclass}がある影響で
        型註釈が省略できない場合が顕著にみられ，
        それゆえかトップレヴェルで定義する函数には必ず型註釈を入れる慣習がある．
        たまに「型が函数定義の本体であって，実装はオマケにすぎない」
        という主張をする人がいるが，これは
        （\dfnje{篩型}{refinement type} \cite[
          `FreemanPfenning1991PLDI`; `KnowlesFlanagan2007ESOP`;
          `RondonKawaguchiJhala2008PLDI`;
        ];のような，
        通常の型よりもずっと強力な型を扱う型システムでもない限り）
        過言気味だ．
        型から実装が決まるわけでは決してないためだ．
        例えば返り値の型が\type(Type.bool);の函数なら，
        “最後に\codem{not}をかませるような実装に変更する” だけで
        元と同一の型がつくが振舞いの全く異なる函数の実装ができてしまう．
      }．
      こうした考察から多くの言語には型システムによる静的な検査が搭載されており，
      我々のコーディングを型検査器が支えてくれるようになっている．
      \SATySFi;も，そんな言語のひとつである．
    }
  >
  +subsection{タプル}<
    +p{
      \dfnje{タプル}{tuple}とは “複数の式を並べてひとまとめにした式” であり，
      数学的に言えば直積に相当するものだ．タプルは式として次のような形をもつ：

      \d-codem{
        (\metasub(${1}){expr}, ${\ldots}, \metasub(${n}){expr})
      }%

      ただし ${n \geq 2}．
      各式\codem{\metasub(${i}){expr}}が\type(Type.tymtausub ${i});をもつとき，
      上記のタプルは以下のような型をもつ：

      \quote{
        \type(Type.(product [tymtausub ${1}; tymtausub ${2};
          of-math ${\cdots}; tymtausub ${n}]));
      }%

      代表的な用途として，“複数の値を返り値にしたい時” がある．
      例として，2つの整数を受け取ってその除算の商と剰余を一緒に返す函数\codem{div-rem}を定義してみる：

      \d-code(```
        let div-rem m n =
          (m / n, m mod n)
      ```);%

      こうして定義した\codem{div-rem}には
      \type(Type.(int --> (int --> product [int; int])));型がつく\footnote{
        型の記法では，${\ast} は ${\to} より結合が強いとする．
        すなわちここでは
        \type(Type.(int --> (int --> synt-paren (product [int; int]))));
        を指す．
      }．
      一方で，これを使う側はどうしたらよいのだろう？\quad;
      このために，タプルを “分解” する方法が用意されている．
      \dfnje{パターンマッチ}{pattern matching}と呼ばれる構文である．
      パターンマッチは条件分岐を強化したようなもので，
      “値の形” によって分岐させる機構である．
      \codem{div-rem}を用いて，
      “第1引数の整数以上の値にするには第2引数を少なくとも何倍すればよいか” を返す函数
      \codem{make-exceed}を定義してみる：

      \d-code(```
        let make-exceed n q =
          match div-rem n q with
          | (m, 0) -> m
          | (m, _) -> m + 1
      ```);%

      ここで登場した次のような構文の式がパターンマッチを実現する
      \dfnje{match式}{match-expression}である：

      \d-codem{
        match \meta{expr} with
        \| \metasub(${1}){pat} -\> \metasub(${1}){expr} \| ${\cdots} \|
          \metasub(${n}){pat} -\> \metasub(${n}){expr}
      }%

      ただし ${n \geq 1}で，\codem{with}の直後の\codem{\|}は省略してもよい．
      各\codem{\metasub(${i}){pat}}は\dfnje{パターン}{pattern}と呼ばれるものであり，
      “値の形” を表す．
      パターンの中には変数または\dfnje{ワイルドカード}{wildcard}である\codem{\_}を含めてよく，
      そこは “どんな形でもマッチする” ものと扱われる．
      match式は，まず\codem{\meta{expr}}を評価し，その結果得られた値が
      各パターン\codem{\metasub(${i}){pat}}のどれに合致する “形” をしているかを
      先に挙げたパターンほど優先で選択し，パターン中の変数を該当箇所の実際の値に束縛してから，
      それに対応する式\codem{\metasub(${i}){expr}}を評価する．
      上記の例では，\codem{div-rem}が返すタプルの2番目の値，
      つまり剰余に相当する部分が\codem{0}である場合は，
      変数\codem{m}をタプルの1番目の値に束縛し，そのパターンに対応する式である\codem{m}を返す．
      つまり，この場合は単に割った商を返している．
      一方で，最初のパターンにマッチしなかった場合は，
      2番目のパターンにマッチさせ，同様に変数\codem{m}を用いて商を取り出し，
      それに\codem{1}を加えて返す．
      パターンの順番は重要である．もし上の例で
      \codem{\| (m, _) -\> m + 1}を\codem{\| (m, 0) -\> m}よりも先に書いていたら，
      定義される\codem{make-exceed}は単に “商に${1}足して返す函数” になってしまう
      （つまり，\codem{n}が\codem{q}で割り切れる場合の返り値が異なる）．
      型の観点からは，各\codem{\metasub(${i}){expr}}の型はすべて一致する必要があり，
      その一致した型がmatch式全体のもつ型になる．
      また，パターンがひとつだけのmatch式
      \codem{match \meta{expr} with \metasub(${1}){pat} -\> \metasub(${1}){expr}}
      は\codem{let}を用いて

      \d-codem{
        let \metasub(${1}){pat} = \meta{expr} in \metasub(${1}){expr}
      }%

      という糖衣構文で書くことができる．別の例として
      “長さと平面座標を受け取り，その座標を ${+x} 方向に与えられた長さだけ移動させる函数”
      \codem{shift-x}を定義してみよう：

      \d-code(```
        let shift-x len point =
          let (x, y) = point in
          (x +' len, y)
      ```);%

      このように\codem{let}でタプルを分解できるのである．
      こうして定めた\codem{shift-x}は
      \type(Type.(length --> (product [length; length] --> product [length; length])));
      型をもつ．
      さらには，パターンを引数に直接書くこともできる．
      以下のように書いても，上での定義と等価に振舞う函数が定義できる：

      \d-code(```
        let shift-x len (x, y) =
          (x +' len, y)
      ```);%

      駆け足気味であったが，以上がタプルとパターンマッチの基礎である．
    }
  >
  +subsection{代数的データ型}<
    +p{
      \dfnje{代数的データ型}{algebraic data type, ADT}は，
      非常に大雑把に言えば “構成に独立な複数の方法があるデータ” を扱う型である．
      \dfnje{ヴァリアント型}{variant type}とか
      \dfnje{合併型}{union type}と呼ばれることもあり\footnote{
        「合併型」や “union type” は\dfn{Elm}などの言語で用いられる用語だが，
        型システムの議論ではこれらの語がよく似た別物を指すこともあるので注意を要する．
      }，
      数学的には直和に対応する．
    }
    +p{
      代数的データ型を扱う必要性を感じるために，
      まず「長方形または円からなる図形のデータを扱いたい」という場面を考える．
      長方形は対角線をなす2点を記録すればよく，
      円は中心座標と半径を記録すればよいだろう．
      それぞれ図形に対して一意的な表現方法にはなっていないが，それは特に問題にせず，
      単にデータとして不足なく保持できればよい．
      ここまでに紹介した言語機能を用いて長方形と円を一緒に扱うナイーヴな方法のひとつは，
      \type(Type.(product [string; length; length; length; length]));
      という型のタプルを用いる方法だ．
      ${\tuple{|x_{1}|y_{1}|}} と ${\tuple{|x_{2}|y_{2}|}} とが対角線をなす長方形は
      \codem{(\`rectangle\`, \metasub(${1}){x}, \metasub(${1}){y},
        \metasub(${2}){x}, \metasub(${2}){y})}
      で，
      ${\tuple{|x|y|}} を中心とする半径 ${r} の円は
      \codem{(\`circle\`, \meta{x}, \meta{y}, \meta{r}, 0pt)}
      でそれぞれ表すことにするのである．
      しかし，これはかなり “荒っぽい” 方法であり，いくつもの問題を孕んでいる．
      まず\codem{(\`hoge\`, 2pt, -5pt, 0pt, 3pt)}のような
      “意味をなさないデータ” が同じ型で作れてしまう．
      勿論図形を受け取る各函数でそのデータが正しいか逐一確認することはできるが，
      複雑な処理では確認を忘れてしまうことも十分ありうるし，
      何より正しくないデータだった場合に実行時エラーにするしかないのは不便である．
      このほか，図形が格納された変数\codem{geom}に対して
      \codem{let (_, _, _, x, _) = geom in ${\cdots}}
      として\codem{x}に値を取り出せるが，この\codem{x}は図形ごとに
      全然違う役割を担っている．
      このような操作が安易にできてしまうと，複雑化するにしたがって見つけにくい実装のミスに繋がる．
    }
    +p{
      代数的データ型を用いれば，このような状況をはるかにスマートに扱える．
      まずは具体例として，上で挙げた図形を扱うための型
      \type(Type.(base-type {geometry}));を定義してみる：

      \d-code(```
        type geometry =
          | Rectangle of (length * length) * (length * length)
          | Circle    of (length * length) * length
      ```);%

      この定義は，新たに定義する\type(Type.(base-type {geometry}));型に於いて

      \listing{
        * ${\tuple{|x_{1}|y_{1}|}} と ${\tuple{|x_{2}|y_{2}|}} とが対角線をなす長方形は
          \codem{Rectangle((\metasub(${1}){x}, \metasub(${1}){y}),
            (\metasub(${2}){x}, \metasub(${2}){y}))}
          という形で扱われる

        * ${\tuple{|x|y|}} を中心とする半径 ${r} の円が
          \codem{Circle((\meta{x}, \meta{y}), \meta{r})}
          という形で扱われる

        * この形以外のデータは扱わない
      }%

      ということを宣言している．
      この宣言以降，\codem{Rectangle \meta{expr}}および
      \codem{Circle \meta{expr}}で
      \type(Type.(base-type {geometry}));型のつく式を書ける．
      一般に代数的データ型の定義は以下のような構文で宣言される：

      \d-codem{
        type \metasub(${1}){'a} ${\cdots} \metasub(${m}){'a} \meta{tyname} =
          \| \metasub(${1}){Ctr} of \metasub(${1}){ty}
          \| ${\cdots}
          \| \metasub(${n}){Ctr} of \metasub(${n}){ty}
      }%

      ただし ${m \geq 0} かつ ${n \geq 1}で，また\codem{=}の直後の\codem{\|}は省略でき，
      宣言される型の名前\meta{tyname}に使えるのは変数名に使える文字列である．
      各\codem{\metasub(${i}){Ctr}}は\dfnje{コンストラクタ}{constructor}と呼ばれ，
      コード中の相異なる文字列である．
      コンストラクタとして使えるのは

      \listing{
        * 1文字目はラテン大文字
        * 2文字目以降は大小ラテン文字，数字，ハイフンのいずれか
      }%

      を満たす1文字以上の長さの文字列である．
      \codem{\meta{Ctr} of \meta{ty}}は
      \codem{\meta{Ctr}}と書く構文もあり，
      これは\codem{\meta{Ctr} of unit}と等価である．
      \type(Type.unit);型は唯一の値\codem{()}をもつ型で，
      \ref-subsection(`imperative`);で説明するような手続き的処理の返り値や，
      手続き的処理を行なう函数の引数などにダミー的に利用される\footnote{
        このような用法を\dfnje{サンク}{thunk}などと呼ぶ．
      }．
      \codem{\metasub(${j}){'a}}は\dfn{型引数}と呼ばれるものだが，
      今は触れず，${m = 0} とする．
    }
    +p{
      さて，代数的データ型とそれに属するデータの作り方はわかったが，
      そのデータをどうやって使えばいいのだろう？\quad;
      実は代数的データ型のデータも，タプルと同様にパターンマッチによって分解する．
      例として，上で定義した\type(Type.(base-type {geometry}));型のデータを受け取って
      その（平方センチメートル単位の）面積を浮動小数点数で返す函数
      \codem{area} : \type(Type.(base-type {geometry} --> float));を定義してみる：

      \d-code(```
        let pi = 3.1415926535

        let length-abs len =
          if len <' 0pt then 0pt -' len else len

        let area geom =
          match geom with
          | Rectangle((x1, y1), (x2, y2)) ->
              let w = (length-abs (x1 -' x2) /' 1cm) in
              let h = (length-abs (y1 -' y2) /' 1cm) in
                w *. h

          | Circle(_, r) ->
              let rf = r /' 1cm in
                rf *. rf *. pi
      ```);%

      与えられた図形が長方形なのか円なのかパターンマッチで分岐して処理している．
      \codem{\meta{Ctr}}が何らかのデータ型に属するものとして定義済みのコンストラクタであるとき，
      \codem{\meta{Ctr} \meta{pat}}がパターンとして使え，
      \codem{\meta{Ctr} \meta{v}}の形の値が
      （\codem{\meta{v}}が\codem{\meta{pat}}にマッチするときに）マッチするのである．
      上で定義した\codem{area}を実際に使ってみよう：

      \d-code-and-block(```
        +p{ Answer:
          \show-float(area (Rectangle((1cm, 2.4cm), (-3cm, 10cm)))); }
        +p{ Answer:
          \show-float(area (Circle((5cm, 0cm), 2cm))); }
      ```)(open Sample in '<
        +p{ Answer:
          \show-float(area (Rectangle((1cm, 2.4cm), (-3cm, 10cm)))); }
        +p{ Answer:
          \show-float(area (Circle((5cm, 0cm), 2cm))); }
      >);%

      長方形と円のそれぞれについて正しく面積が計算できていることがわかる．
    }
    +p{
      \SATySFi;には，いくつかの代数的データ型がデフォルトで備わっている．
      特に組版処理特有のデータは次のように定義される\type(Type.color);型である：

      \d-code(```
        type color =
          | Gray of float
          | RGB  of float * float * float
          | CMYK of float * float * float * float
      ```);%

      \codem{Gray}，\codem{RGB}，\codem{CMYK}は
      それぞれグレイスケール，RGB，CMYKの色空間で色を表現するためのコンストラクタで，
      PDFの仕様に於ける
      \code(`/DeviceGray`);，\code(`/DeviceRGB`);，\no-break{\code(`/DeviceCMYK`);}に
      それぞれ対応する．
      引数の各数値は\codem{0.}で最小，\codem{1.}で最大を表し，
      例えば\codem{Gray(0.)}は黒，\codem{Gray(1.)}は白，
      \codem{RGB(1., 0., 0.)}は赤，といった具合である．
      この\type(Type.color);型は，\ref-chapter(`graphics`);で紹介する
      グラフィックス関連の種々の記述で使われるほか，
      \pkg{color}パッケージではこの型を用いていくつかの頻出の色が定義されている．
    }
  >
  +subsection{再帰函数}<
    +p{
      この節では\dfnje{再帰函数}{recursive function}を扱う．
      再帰函数とは，簡単に言えば
      “定義中で自分自身を呼び出すように記述されている函数” である．
      再帰函数の説明としてあまりにも月並みではあるが，
      例として整数の階乗を求める函数\codem{fact}を定義する
      （ただし，ここでは ${0\! \defeq 1} と定めるものとする）：

      \d-code(```
        let-rec fact n =
          if n <= 0 then 1 else n * fact (n - 1)
      ```);%

      \codem{let}の代わりに\codem{let-rec}から始める構文である．
      とりあえず使ってみて，結果が期待どおりであることを確認しよう：

      \d-code-and-block(```
        +p{ Answer: \show-int(fact 6); }
      ```)(open Sample in '<
        +p{ Answer: \show-int(fact 6); }
      >);%

      再帰函数の定義は，一般には以下のような形をしている：

      \d-codem{
        let-rec \meta{f} \metasub(${1}){x} ${\cdots} \metasub(${n}){x} =
          \metasub(${1}){expr}
        in
          \metasub(${2}){expr}
      }%

      \codem{let}の場合とは違い，\codem{\metasub(${1}){expr}}の中でも
      定義しようとしている\codem{\meta{f}}が使えるのが特徴である．
      ただし，この\codem{let-rec}による定義では，
      糖衣構文を “はがした” 上で最終的に\codem{\meta{f}}が束縛される式は
      函数の形の式\codem{(fun \meta{x} -\> \meta{expr})}でなければならず，
      したがって\codem{let-rec n = n + 1}のような定義は書けないようになっている．
      さて，もとの例である\codem{fact}の定義を理解しよう．
      これはたしかに\codem{fact \meta{n}}で階乗 ${n\!} を返すような定義になっており，
      慣れれば一目瞭然なのだが，
      “プログラムを手続き的に理解するという観念に拘束されている人” には少し飛躍があるかもしれない．
      再帰函数はいわゆる函数型プログラミングを最大に特徴づける重要な点とさえ言えるので是非とも理解されたい．
      再帰を理解する有用な直観は，いわゆる数学的帰納法によく似ている．
      すなわち，“より小さいものに対する解決がより大きいものの解決に使える” のである．
      上記の\codem{fact}の定義は，次のような直観に基づいて理解できる：

      \listing{
        * 与えられた引数が\codem{0}（またはそれ未満）の場合は，
          返り値として即座に\codem{1}を返してよい．

        * 与えられた引数\codem{\meta{n}}が\codem{1}以上の場合，
          返すべき値は\codem{\meta{n}}と\codem{\meta{n} - 1}の階乗との積である．
          したがって，\codem{\meta{n} - 1}の階乗を（\codem{fact}自分自身を呼び出すことで）計算し，
          その計算結果に\codem{\meta{n}}を掛けて返り値とすればよい．
      }%

      或る意味では，階乗函数の（数学的な）定義：

      \align[
        ${| 0\! |\defeq 1 |};
        ${| n\! |\defeq n \times \paren{n - 1}\! \text!{\quad;(${n \geq 1})} |};
      ];%

      に近い記述ができているとも言える．
      ともかく，「再帰は再帰がわかるとわかる」のだ．
    }
    +p{
      さて，ここで少し\dfnje{多相型}{polymorphic type}の話をしよう．
      まず以下のような函数を見てほしい：

      \d-code(```
        let proj1 tuple =
          let (x, _) = tuple in x
      ```);%

      この函数につく型はなんだろうか？\quad;
      ひとまず，例えば\type(Type.(product [int; string] --> int));
      などはつくはずであるが，よくよく見直すと
      \type(Type.(product [tymtausub ${1}; tymtausub ${2}] --> tymtausub ${1}));%
      という形の型は全部つくということがわかる．
      これを反映して，let多相では上記の\codem{proj1}に

      \quote{
        \type(Type.(forall ${\alpha} (forall ${\beta} (product [tymalpha; tymbeta] --> tymalpha))));
      }%

      という型をつける．ここでの ${\alpha} や ${\beta} は\dfnje{型変数}{type variable}と呼ばれ，
      実際に\codem{proj1}が使われるたびに（“整合する” 限りに於いて）適切な型をあてはめて使われる．
      例えば上記の\codem{proj1}の定義以降で
      \codem{(proj1 (1cm, 2cm), proj1 (\`foo\`, 1))}などと書いても
      （ふたつの\codem{proj1}は異なる型の引数を受け取っているにもかかわらず）問題なく型がつく．
      多相型をつける一般的な規則を述べると長くなるため事細かには述べないが，
      基本的にはletで束縛される変数の型に関して型推論の結果特に型が決定しない部分は型変数として一般化され，
      多相型がつくという仕組みになっている．
    }
    +p{
      多相型について把握してもらったところで，代数的データ型で一旦無視していた型引数の説明をしよう．
      型引数は，多相な代数的データ型を定義するための機構である．
      例として，最初から備わっている代数的データ型のひとつである
      \type(Type.(option tymalpha));型について見てみる．
      この型は，以下のように定義できるものだ：

      \d-code(```
        type 'a option = None | Some of 'a
      ```);%

      \codem{'a}というひとつの型引数をとる定義である．
      型引数は，その代数的データ型の定義中で型として使うことができる．
      \type(Type.(option tymalpha));型は，直観的には
      “\type(Type.tymalpha);型の値ひとつか，或いは何もないか” を表現する型である．
      もう少し具体的な用途を挙げて直観を説明するなら，
      “成功した時は\type(Type.tymalpha);型の値を返したいが，失敗するかもしれない函数”
      の返り値の型として使ったりする．
      例えば “実行時に失敗しない安全な除算” は以下のように定式化できる：

      \d-code(```
        let div-safe m n =
          if n == 0 then None else Some(m / n)
      ```);%

      この\codem{div-safe}は\type(Type.(int --> (int --> option int)));型をもつ．
    }
    +p{
      \codem{div-safe}は型引数に具体的に当てはまる型が\type(Type.int);型に決定していたが，
      重要なのはこれを多相なままにできるということである．

      \d-code(```
        let from-option d opt =
          match opt with None -> d | Some(v) -> v
      ```);%

      \codem{from-option}は，第2引数に与えられた値が\codem{None}のときは “デフォルト値” として
      第1引数\codem{\meta{d}}を返し，\codem{Some(\meta{v})}の形のときはその\codem{\meta{v}}を
      取り出して返すことで\type(Type.(option tymtau));型のデータを
      \type(Type.tymtau);型へと “潰す” 函数である．
      これは\type(Type.tymtau);という型によらず同様であり，実際
      この\codem{from-option}には\type(Type.(forall ${\alpha} (tymalpha --> (option tymalpha --> tymalpha))));
      という多相型がつく．
    }
    +p{
      さらに代数的データ型の話を続けよう．
      実は，代数的データ型の重要な特徴として，再帰的なデータを扱う型を定義できるというものがある．
      例として，二分木を扱う代数的データ型は以下のように定義できる：

      \d-code(```
        type 'a bin-tree =
          | Empty | Node of 'a * 'a bin-tree * 'a bin-tree
      ```);%

      \type(Type.(ctr-type {bin-tree} [tymalpha]));型の定義の中に
      \type(Type.(ctr-type {bin-tree} [tymalpha]));型自身が現れている．
      この型に基づく二分木を文字列に変換する函数\codem{show-tree}は
      以下のように定義できる：

      \d-code(```
        let-rec show-tree pr tr =
          match tr with
          | Empty -> `_`
          | Node(x, trL, trR) ->
              `(` ^ (pr x) ^ #` `# ^
                (show-tree pr trL) ^ #` `# ^ (show-tree pr trR) ^ `)`
      ```);%

      この\codem{show-tree}につく型は
      \type(Type.(forall ${\alpha} ((tymalpha --> string) -->
        (ctr-type {bin-tree} [tymalpha] --> string))));
      である．引数\codem{pr}も函数であることに注目されたい．
      \codem{show-tree}は函数を受け取ってそれを使う函数になっており，
      このような函数を\dfnje{高階函数}{higher-order function}と呼ぶ．
      型も，それに対応して\type(Type.(tymalpha --> string));が引数側にきている．
    }
    +p{
      最も汎用性の高い再帰的なデータ型は，おそらく\dfnje{リスト}{list}だろう．
      リストとは\codem{[3\; 1\; 4\; 1\; 5\; 9\; 2]}といったように
      基本的に “同じ種類データが有限個並んだもの” であり，
      \type(Type.tymtau);型のデータが並んだリストを
      \type(Type.(list tymtau));型がつくものとして扱うのだが，
      リストを構築・分解する方法の直観とは少し飛躍がある：\quad;
      リストの構築方法は

      \listing{
        * 空リスト\codem{[]}
        * 要素\codem{\meta{x}}とリスト\codem{\meta{xs}}の結合\codem{\meta{x} :: \meta{xs}}
      }%

      の2種類があり，\codem{[3\; 1\; 4\; 1\; 5\; 9\; 2]}は
      \codem{3 :: (1 :: (4 :: (1 :: (5 :: (9 :: (2 :: []))))))}の糖衣構文なのである\footnote{
        \codem{::}は右結合なので，ここでつけている括弧は全て省略できる．
      }．
      要するに，リストとは（模擬的には）以下で定義される代数的データ型に相当する：

      \d-code(```
        type 'a list = [] | (::) of 'a * 'a list
      ```);%

      リストに対する簡単な処理をいくつか見てみる．
      まずリストを受け取ってその長さを返す函数\codem{list-length}は以下のとおり：

      \d-code(```
        let-rec list-length l =
          match l with
          | []      -> 0
          | x :: xs -> 1 + list-length xs
      ```);%

      ふたつのリストを結合する函数\codem{list-append}は以下のとおり：

      \d-code(```
        let-rec list-append l1 l2 =
          match l1 with
          | []      -> l2
          | x :: xs -> x :: list-append xs l2
      ```);%

      リストを前後反転する函数\codem{list-reverse}は，
      前2つの例に比べて少し技巧的だが以下のように実装できる：

      \d-code(```
        let list-reverse l =
          let-rec aux acc l =
            match l with
            | []      -> acc
            | x :: xs -> aux (x :: acc) xs
          in
          aux [] l
      ```);%

      かなり駆け足の説明のため基礎的な函数のみの紹介となってしまったが，
      リストに対する操作，例えばマップ函数や畳み込み函数は，
      内容の充実した函数型プログラミングの入門書では必ず触れるものなので，
      是非参照されたい．
      なお，リストに対する操作は\pkg{list}パッケージでいくつも定義されており，
      ここで例示した\codem{list-length}，\codem{list-append}，\codem{list-reverse}も
      \codem{List.length}，\codem{List.append}，\codem{List.reverse}として
      それぞれ実装されている．
    }
    +p{
      \ref-chapter(`getting-started`);で登場した\type(Type.itemize);型も，
      実はあらかじめ定義されている以下のような再帰的な代数的データ型である：

      \d-code(```
        type itemize = Item of inline-text * itemize list
      ```);%

      そして，\codem{\\listing}などのコマンドに渡される

      \d-code(```
        { * 東京
            ** 本郷
            ** 弥生
            ** 浅野
            ** 駒場
          * 千葉
            ** 柏 }
      ```);%

      という記述は，以下のような構造の糖衣構文である：

      \d-code(```
        (Item(` `, [
          Item({東京}, [
            Item({本郷}, []);
            Item({弥生}, []);
            Item({浅野}, []);
            Item({駒場}, []); ]);
          Item({千葉}, [
            Item({柏}, []); ]);
        ]))
      ```);%

      \codem{\\listing}などのコマンドは，この再帰的なデータ構造の上を
      走査して組版処理しているのである．
    }
  >
  +subsection{レコード}<
    +p{
      \dfnje{レコード}{record}は，タプルと同様に “複数の式をまとめて扱う機構” なのだが，
      タプルがデータを “何番目のデータか” に基づいて構築・分解していたのに対し，レコードでは
      それぞれのデータに\dfnje{ラベル}{label}がつけられ，これに基づいて構築したり取り出したりする．
      おおよそ，C言語でいうところの構造体にあたる概念である．
      例として，人物の情報を扱うレコードをまず掲げよう：

      \d-code(```
        (| given-name = `Takashi`; family-name = `Suwa`; age = 25; |)
      ```);%

      ここでの\codem{given-name}，\codem{family-name}，\codem{age}がラベルである．
      ラベルに使える文字列は変数名に使えるそれと同じ範囲である．
      レコード\codem{\meta{r}}からの内容の取り出しは
      \codem{\meta{r}\#\meta{label}}という式によって行なう．
      例えば上記のレコードが\codem{r-tsuwa}という変数に格納されているとき，
      \codem{r-tsuwa\#age}は\codem{25}へと評価される．
      実は，レコードは\SATySFi;で文書を書くユーザならほぼ全員使っているはずである．
      というのも，大抵のクラスファイルでは\codem{document}の直後に文書に関する情報を
      レコードで渡すようなインターフェイスになっているからだ．
      そう，以下の\codem{(\| ${\cdots} \|)}の部分はレコードだったのである．

      \d-code(```
        @require: stdjareport

        document (|
          title = {はじめての文書};
          author = {組 版太郎};
        |) '<
        （以降略）
      ```);%
    }
    +p{
      レコードのラベルという仕組みは
      タプルに比べて各要素がどのような役割を果たしているかが明瞭であり，
      プログラムのドキュメント性を向上させる効能があるが，
      型つけに関してさらに顕著な違いがある．
      \SATySFi;でのレコードに関する型つけ規則は，
      \dfn{SML\#}を基礎づける型システム \cite[`Ohori1995`];を大々的に参考にしている．
      この型システムについて定義をすべて述べるのはあまりにも長いので，
      簡素に直観だけを与える．詳細は元論文 \cite[`Ohori1995`];を参照されたい．
      まず，基本的にレコード：

      \d-codem{
        (\| \metasub(${1}){label} = \metasub(${1}){expr}\; ${\cdots}\;
            \metasub(${n}){label} = \metasub(${n}){expr}\; \|)
      }%

      は，各式\codem{\metasub(${i}){expr}}に型\type(Type.tymtausub ${i});がつく下で

      \quote{
          ${\Type.record-paren{
            \text!{\metasub(${1}){label}} : \mtype!(Type.(tymtausub ${1}))\;
            \ \cdots\;
            \ \text!{\metasub(${n}){label}} : \mtype!(Type.(tymtausub ${n}))
          }}
      }%

      という型をつけて扱う．レコードそのものの型つけは単純なのだが，
      重要なのはラベルへのアクセスに関する型つけである．
      レコードを受け取り，そのレコードのラベル\codem{foo}にアクセスする函数を考える：

      \d-code(```
        let f r = r#foo + 1
      ```);%

      この函数\codem{f}にどんな型をつければよいかをまず素朴に考えよう．
      この函数の式が型の制約として要請するのは，
      \codem{r}という変数が束縛されているレコードが\codem{foo}というラベルをもち，
      かつそれに対応する値が\type(Type.int);型であるということだけである．
      この函数を\SATySFi;では（SML\#に倣って）

      \quote{
        \type(Type.(forall-kinded ${\alpha} [({foo}, int)] (tymalpha --> int)));
      }%

      という型をつけて扱う．これは ${\alpha} が一般化されている或る種の多相型なのだが，
      重要なのは「:: \type(Type.(record [({foo}, int)]));」の部分であり，
      これは ${\alpha} が（任意の型ではなく）ラベルfooに\type(Type.int);型をもつ
      レコードの型のみを動く型変数であるということを記述している．
      同様にして

      \d-code(```
        let g r =
          let (x, _) = r#bar in r#foo + (round x)
      ```);%

      で定義される\codem{g}には以下のような型がつく：

      \quote{
        \type(Type.(forall ${\beta} (forall-kinded ${\alpha} [
          ({foo}, int);
          ({bar}, product [float; tymbeta]);
        ] (tymalpha --> int))));
      }%

      一般的な説明は煩雑なので省くが，おおよそこのような仕組みでレコードに関して
      多相型がつけられる．

    }
  >
  +subsection?:(`imperative`){手続き}<
    +p{
      いわゆる函数型言語ではあるものの，\SATySFi;にも手続き的処理を行なう機構は備わっている．
      すなわち，書き換え可能な変数に相当する\dfnje{可変参照}{mutable reference}である．
      可変参照は，次のような構文で宣言する：

      \d-codem{
        let-mutable \meta{x} \<- \metasub(${1}){expr} in \metasub(${2}){expr}
      }%

      \codem{\meta{x}}が宣言される可変参照であり，
      \codem{\metasub(${1}){expr}}がその初期値，
      \codem{\metasub(${2}){expr}}が\codem{\meta{x}}の使えるスコープである．
      可変参照は基本的には通常の変数と同様の扱いであるものの，
      \type(Type.(tymtau));型の値が格納される可変参照は
      \type(Type.(ref tymtau));型がつけられる．
      可変参照\codem{\meta{x}}の現在の内容は\codem{!\meta{x}}で取得することができ，
      また内容を破壊的に書き換える処理は，
      新たに格納させる内容に評価される式を\codem{\meta{expr}}として
      \codem{\meta{x} \<- \meta{expr}}
      と書く．この式が評価されて\codem{\meta{x}}の内容が上書きされると，
      式全体はユニット値\codem{()}となる．
    }
    +p{
      可変参照は，章節番号の挿入など，“本質的に手続き的な処理” をクラスファイル内で扱うのに利用されているので，
      各種クラスファイルの中を覗くと多くの用例が確認できるだろう．
      ただし，多くの場合可変参照を多用するとプログラムの挙動を把握困難にする要因となる\footnote{
        だからこそいわゆる函数型プログラミングの流儀は
        破壊的代入を積極的に避けるのである．
      }ので，
      止むを得ない場合を除いてできる限り使わないように心がけた方が良さそうである．
    }
  >
  +subsection?:(`arithmetic`){算術に関するプリミティヴ}<
    +p{
      主な “算術演算” 用のプリミティヴについてまとめて紹介する：

      \vals-explain({|+|-|\*|})(tyarithI) {
        整数の加算，減算，乗算．
      }%
      \vals-explain({|/|mod|})(tyarithI) {
        整数の除算と剰余．
        \codem{mod}は通常の変数名のように見えるが，例外的に2項演算子である．
        いずれも第2引数に\codem{0}が与えられた場合は実行時エラーとなる．
      }%
      \vals-explain({|==|\<\>|})(tycompI) {
        整数の等号と不等号．
      }%
      \vals-explain({|\>|\<|\>=|\<=|})(tycompI) {
        “大なり”，“小なり”，“大なりイコール”，“小なりイコール”．
      }%

      % -- 真偽値 --
      \vals-explain({|\&\&|\|\||})(tylogical) {
        連言と選言．
      }%
      \val-explain({not})(Type.(bool --> bool)) {
        否定．
      }%

      % -- 浮動小数点数 --
      \val-explain({float})(Type.(int --> float)) {
        整数を浮動小数点数に変換する．
      }%
      \val-explain({round})(Type.(float --> int)) {
        浮動小数点数を，小数部分を切り捨てて整数に変換する．
        引数が正負無限やNaN，あるいは小数部分を切り捨てた整数が\type(Type.int);型で
        表現不可能なときの結果は未定義．
      }%
      \vals-explain({|+.|-.|\*.|/.|})(tyarithF) {
        浮動小数点数の加算，減算，乗算，除算．
      }%
      \vals-explain({|sin|cos|tan|asin|acos|atan|})(tysine) {
        正弦，余弦，正接函数，およびアークサイン，アークコサイン，アークタンジェント
        （すなわち正弦，余弦，正接函数の “逆函数”）．
      }%
      \val-explain({atan2})(Type.(float --> (float --> float))) {
        \codem{atan2 \meta{y} \meta{x}}で
        \codem{\meta{y} /. \meta{x}}のアークタンジェントを返すが，
        \codem{\meta{y}}と\codem{\meta{x}}の符号が象限の決定に用いられる．
        返される値は ${\mathord{-}\pi} から ${\pi} の間の値である．
      }%

      % -- 長さ --
      \vals-explain({|+'|-'|})(Type.(length --> (length --> length))) {
        長さの加算と減算．
      }%
      \val-explain({\*'})(Type.(length --> (float --> length))) {
        長さのスカラー倍．
      }%
      \val-explain({/'})(Type.(length --> (length --> float))) {
        長さの “除算”．
      }%
      \vals-explain({|\>'|\<'|})(Type.(length --> (length --> bool))) {
        長さの “大なり” と “小なり”．
      }%

      % -- 文字列 --
      \val-explain({^})(Type.(string --> (string --> string))) {
        文字列の結合．
      }%
      \val-explain({arabic})(Type.(int --> string)) {
        整数を十進文字列に変換する．
      }%
      \val-explain({show-float})(Type.(float --> string)) {
        浮動小数点数を十進文字列に変換する．
      }%
      \val-explain({string-same})(Type.(string --> (string --> bool))) {
        文字列の等価性の判定．
        バイト列として等価かどうかの判定であり，
        Unicodeによって規定された正規化等は行なわない．
      }%
      \val-explain({string-sub})(Type.(string --> (int --> (int --> string)))) {
        \codem{string-sub \meta{s} \meta{i} \meta{l}}で
        文字列\codem{\meta{s}}の第\codem{\meta{i}}番目の文字を先頭とする
        長さ\codem{\meta{l}}の部分文字列を取り出す．
        文字数はUnicodeコードポイント単位．
        \codem{\meta{i}}と\codem{\meta{l}}による
        指定が部分文字列の範囲でない場合は実行時エラーが出る．
      }%
      \val-explain({string-length})(Type.(string --> int)) {
        与えられた文字列がUnicodeコードポイント単位で何文字かを返す．
      }%
      \val-explain({string-unexplode})(Type.(list int --> string)) {
        与えられた整数列の各整数をUnicodeコードポイントと解釈した文字列を返す．
        Unicodeコードポイントの範囲にない整数が与えられた場合の動作は未定義．
      }%
      \val-explain({embed-string})(Type.(string --> inline-text)) {
        文字列をインラインテキストに変換する．
      }%
      \val-explain({split-into-lines})%
        (Type.(string --> list (product [int; string]))) {
          与えられた文字列を各行に分解してリストを返す．
          返されるリストの各要素\codem{(\meta{i}, \meta{s})}は
          “インデントが\codem{\meta{i}}個挿入された内容文字列\codem{\meta{s}}の行”
          に相当する．
        }%

       \val-explain({!})%
         (Type.(forall ${\alpha} (ref tymalpha --> tymalpha))) {
           \codem{!\meta{r}}で可変参照\codem{\meta{r}}の参照する現在の値を返す．
         }%
       \val-explain({::})(Type.(forall ${\alpha}
         (tymalpha --> (list tymalpha --> list tymalpha)))) {
           リストの “コンス”，すなわち第1引数を第2引数のリストの先頭につけてできるリストを返す．
         }%
       \val-explain({\|\>})(Type.(forall ${\alpha} (forall ${\beta}
         (tymalpha --> ((tymalpha --> tymbeta) --> tymbeta))))) {
           前後逆の函数適用，すなわち
           \codem{\meta{x} \|\> \meta{f}}で
           \codem{\meta{f} \meta{x}}に同じ．
           ただし，式\codem{\meta{x}}と\codem{\meta{f}}の評価に
           ともに “副作用” がある場合は評価順序の逆転に注意を要する．
         }%
       \val-explain({display-message})(Type.(string --> unit)) {
         与えられた文字列を1行として標準出力に表示する．
       }%
    }
  >
  +subsection?:(`diff-from-ocaml`){OCamlとの顕著な差異}<
    +p{
      すでに述べたように
      プログラミング言語としての\SATySFi;は
      OCamlにかなり近いものとなっているが，
      非互換な違いがいくつか顕著にある．
    }
    +desc{変数名}{
      おそらくコードの見た目上これが最も目につく違いである．
      変数名はラテン小文字から始まり，
      2文字目以降は大小ラテン文字，数字，ハイフンのいずれかでなければならない．
      アンダースコア（\codem{_}）や
      引用符（\codem{'}）は使えないことに注意．
    }
    +desc{再帰函数の定義}{
      再帰函数の定義には，OCamlの\code(`let rec`);の代わりに
      \codem{let-rec}を用いる．これで1トークンである．
    }
    +desc{型コンストラクタの構文}{
      \SATySFi;では，型コンストラクタ\codem{\meta{tyconstr}}の “適用” は
      \codem{\metasub(${1}){ty} ${\cdots} \metasub(${n}){ty} \meta{tyconstr}}
      という形で書く．これはOCamlの
      \codem{(\metasub(${1}){ty}, ${\ldots}, \metasub(${n}){ty}) \meta{tyconstr}}
      および ${n = 1}の場合の
      \codem{\metasub(${1}){ty} \meta{tyconstr}}
      という形の構文とは明確に異なる．そのかわり，
      OCamlでの\code(`int list list`);のような括弧を省いた “適用” を書くことはできず，
      必ず\codem{(int list) list}と括弧をつけることになる．
    }
    +desc{コンストラクタ}{
      \SATySFi;では，ヴァリアント型のコンストラクタはすべて1引数である．
      \codem{None}のように引数のないコンストラクタの使用は
      \codem{None()}のようにユニット値が省略されているものとして扱われているほか，
      OCamlでは

      \d-code(```
        type foo = Foo of int * int
      ```);%

      と

      \d-code(```
        type foo = Foo of (int * int)
      ```);%

      とで定義される型が異なるが，\SATySFi;では完全に一致する．
    }
    +desc{レコード}{
      まずレコード式を囲む括弧が
      \code(`{`); ${\cdots} \code(`}`);
      の代わりに
      \codem{(\| ${\cdots} \|)}である\footnote{
        これは\codem{\{ ${\cdots} \}}の記法を
        インラインテキストのために明け渡したからである．
      }．
      また，レコード型はnominalではなくstructuralであり，
      したがってレコード式\codem{(\| ${\cdots} \|)}は
      それにつく型を\codem{type ${\cdots}}で宣言せずとも
      書くことができる．
      これは\SATySFi;の型システムがレコードに関して
      \dfn{SML\#}と同様のもの \cite[`Ohori1995`];
      を採用しているからである（詳細は元論文を参照せよ）．
      これに加え，
      OCamlのように特定のフィールドをmutableにするような機能はなく，
      必ず全てのフィールドがimmutableである．
    }
    +desc{可変参照}{
      可変参照はOCamlのように多相函数\code(`ref`);で作るのではなく，

      \d-codem{
        let-mutable \meta{x} \<- \metasub(${1}){expr} in \metasub(${2}){expr}
      }%

      という構文で作るように限定されている．これはOCamlの

      \d-codem{
        let \meta{x} = ref \metasub(${1}){expr} in \metasub(${2}){expr}
      }%

      と同等である．破壊的代入も，OCamlのように\code(`:=`);ではなく，
      \codem{\meta{x} \<- \meta{expr}}と書く．
      \codem{\<-}が多相な2項演算子なのではなく，
      \codem{\meta{x} \<- \meta{expr}}全体が式をなすひとつの構文である．
    }
  >
>
